#!/usr/bin/env bun
import { Command } from "@effect/cli"
import * as Args from "@effect/cli/Args"
import * as Options from "@effect/cli/Options"
import * as FileSystem from "@effect/platform/FileSystem"
import * as Path from "@effect/platform/Path"
import { BunContext, BunRuntime } from "@effect/platform-bun"
import * as Console from "effect/Console"
import * as Data from "effect/Data"
import * as Effect from "effect/Effect"
import { pipe } from "effect/Function"
import * as Option from "effect/Option"

class ServiceNotFoundError extends Data.TaggedError("ServiceNotFoundError")<{
  readonly service: string
}> {}

const resolveProjectRoot = Effect.gen(function* () {
  const path = yield* Path.Path
  const scriptDir = path.dirname(new URL(import.meta.url).pathname)
  return path.resolve(scriptDir, "../..")
})

const loadAnalyzer = (projectRoot: string) =>
  Effect.tryPromise({
    try: () => import(`${projectRoot}/.claude/scripts/analyze-architecture.ts`),
    catch: (error) => new AnalyzerLoadError({ cause: error })
  })

class AnalyzerLoadError extends Data.TaggedError("AnalyzerLoadError")<{
  readonly cause: unknown
}> {}

const runInProjectRoot = <A, E, R>(
  fn: (projectRoot: string, analyzer: any) => Effect.Effect<A, E, R>
): Effect.Effect<A, E | AnalyzerLoadError, R | FileSystem.FileSystem | Path.Path> =>
  Effect.gen(function* () {
    const projectRoot = yield* resolveProjectRoot
    const analyzer = yield* loadAnalyzer(projectRoot)
    const originalCwd = process.cwd()
    process.chdir(projectRoot)
    const result = yield* fn(projectRoot, analyzer).pipe(
      Effect.ensuring(Effect.sync(() => process.chdir(originalCwd)))
    )
    return result
  })

const analyzeCommand = Command.make(
  "analyze",
  {
    metrics: Options.boolean("metrics").pipe(Options.withDefault(false)),
    domains: Options.boolean("domains").pipe(Options.withDefault(false)),
    advanced: Options.boolean("advanced").pipe(Options.withDefault(false)),
    warnings: Options.boolean("warnings").pipe(Options.withDefault(false)),
    workflows: Options.boolean("workflows").pipe(Options.withDefault(false)),
    all: Options.boolean("all").pipe(Options.withDefault(false))
  },
  ({ metrics, domains, advanced, warnings, workflows, all }) =>
    runInProjectRoot((_root, analyzer) =>
      Effect.gen(function* () {
        const graph = yield* analyzer.buildArchitectureGraph
        const output = analyzer.formatAgentWithHints(graph, {
          showMetrics: all || metrics,
          showDomains: all || domains,
          showAdvanced: all || advanced,
          showWarnings: all || warnings,
          showWorkflows: all || workflows
        })
        yield* Console.log(output)
      })
    )
).pipe(
  Command.withDescription("Full dependency graph analysis with progressive disclosure")
)

const blastRadiusCommand = Command.make(
  "blast-radius",
  { service: Args.text({ name: "service" }) },
  ({ service }) =>
    runInProjectRoot((_root, analyzer) =>
      Effect.gen(function* () {
        const graph = yield* analyzer.buildArchitectureGraph
        const analysisGraph = analyzer.buildAnalysisGraph(graph)
        const result = analyzer.computeBlastRadius(analysisGraph, service)
        yield* pipe(
          result,
          Option.match({
            onNone: () =>
              Effect.fail(new ServiceNotFoundError({ service })),
            onSome: (r: any) => Console.log(analyzer.renderBlastRadius(r))
          })
        )
      })
    )
).pipe(
  Command.withDescription("Show downstream impact (who depends on this service)")
)

const commonAncestorsCommand = Command.make(
  "common-ancestors",
  { services: pipe(Args.text({ name: "service" }), Args.atLeast(2)) },
  ({ services }) =>
    runInProjectRoot((_root, analyzer) =>
      Effect.gen(function* () {
        const graph = yield* analyzer.buildArchitectureGraph
        const analysisGraph = analyzer.buildAnalysisGraph(graph)
        const result = analyzer.computeCommonAncestors(analysisGraph, services)
        yield* Console.log(analyzer.renderCommonAncestors(result))
      })
    )
).pipe(
  Command.withDescription("Find shared dependencies across services (root cause analysis)")
)

const ancestorsCommand = Command.make(
  "ancestors",
  { service: Args.text({ name: "service" }) },
  ({ service }) =>
    runInProjectRoot((_root, analyzer) =>
      Effect.gen(function* () {
        const graph = yield* analyzer.buildArchitectureGraph
        const analysisGraph = analyzer.buildAnalysisGraph(graph)
        const result = analyzer.computeAncestors(analysisGraph, service)
        yield* pipe(
          result,
          Option.match({
            onNone: () =>
              Effect.fail(new ServiceNotFoundError({ service })),
            onSome: (r: any) => Console.log(analyzer.renderAncestors(r))
          })
        )
      })
    )
).pipe(
  Command.withDescription("Show all upstream dependencies (full transitive closure)")
)

const metricsCommand = Command.make(
  "metrics",
  {},
  () =>
    runInProjectRoot((_root, analyzer) =>
      Effect.gen(function* () {
        yield* Console.log("<hint>Tip: Use 'architecture analyze --metrics' to see this in full context</hint>")
        yield* Console.log("")
        const graph = yield* analyzer.buildArchitectureGraph
        const fullOutput = analyzer.formatAgent(graph)
        const metricsMatch = fullOutput.match(/<metrics>[\s\S]*?<\/metrics>/)
        yield* Console.log(metricsMatch?.[0] ?? "<metrics />")
      })
    )
).pipe(
  Command.withDescription("Quick health check showing only graph metrics")
)

const domainsCommand = Command.make(
  "domains",
  {},
  () =>
    runInProjectRoot((_root, analyzer) =>
      Effect.gen(function* () {
        const graph = yield* analyzer.buildArchitectureGraph
        const fullOutput = analyzer.formatAgent(graph)
        const domainsMatch = fullOutput.match(/<domains[\s\S]*?<\/domains>/)
        yield* Console.log(domainsMatch?.[0] ?? "<domains />")
      })
    )
).pipe(
  Command.withDescription("Show domain discovery via cut vertices")
)

const hotServicesCommand = Command.make(
  "hot-services",
  {},
  () =>
    runInProjectRoot((_root, analyzer) =>
      Effect.gen(function* () {
        const graph = yield* analyzer.buildArchitectureGraph
        const fullOutput = analyzer.formatAgent(graph)
        const hotMatch = fullOutput.match(/<hot[\s\S]*?<\/hot>/)
        yield* Console.log(hotMatch?.[0] ?? "<hot />")
      })
    )
).pipe(
  Command.withDescription("Show services with high dependent counts (hot services)")
)

type OutputFormat = "mermaid" | "human" | "agent" | "adjacency"

const formatOption = Options.choice("format", ["mermaid", "human", "agent", "adjacency"]).pipe(
  Options.withDefault("agent" as OutputFormat),
  Options.withDescription("Output format: mermaid | human | agent | adjacency")
)

const outputOption = Options.text("output").pipe(
  Options.optional,
  Options.withDescription("Output file path (mermaid format only)")
)

const showErrorsOption = Options.boolean("show-errors").pipe(
  Options.withDefault(false),
  Options.withDescription("Show detailed error types in output")
)

const formatCommand = Command.make(
  "format",
  { format: formatOption, output: outputOption, showErrors: showErrorsOption },
  ({ format, output, showErrors }) =>
    runInProjectRoot((_root, analyzer) =>
      Effect.gen(function* () {
        const fs = yield* FileSystem.FileSystem
        const graph = yield* analyzer.buildArchitectureGraph

        const content =
          format === "mermaid"
            ? analyzer.formatMermaid(graph)
            : format === "human"
              ? analyzer.formatHuman(graph)
              : format === "adjacency"
                ? analyzer.formatAdjacencyList(graph, showErrors)
                : analyzer.formatAgent(graph)

        if (format === "mermaid" && Option.isSome(output)) {
          yield* fs.writeFileString(output.value, content)
          yield* Console.log(`Mermaid diagram written to ${output.value}`)
        } else {
          yield* Console.log(content)
        }

        if (format === "mermaid" && Option.isNone(output)) {
          yield* Console.log("")
          yield* Console.log("=== STATISTICS ===")
          yield* Console.log("")
          yield* Console.log(analyzer.generateStats(graph))
        }
      })
    )
).pipe(
  Command.withDescription("Output analysis in a specific format (mermaid, human, agent, adjacency)")
)

const mainCommand = pipe(
  Command.make("architecture"),
  Command.withDescription("Architecture analysis CLI for Effect service dependency graphs"),
  Command.withSubcommands([
    analyzeCommand,
    blastRadiusCommand,
    commonAncestorsCommand,
    ancestorsCommand,
    metricsCommand,
    domainsCommand,
    hotServicesCommand,
    formatCommand
  ])
)

const cli = Command.run(mainCommand, {
  name: "architecture",
  version: "1.0.0"
})

pipe(
  cli(process.argv),
  Effect.provide(BunContext.layer),
  BunRuntime.runMain
)
